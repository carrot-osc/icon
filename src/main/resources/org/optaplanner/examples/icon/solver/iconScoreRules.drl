package org.optaplanner.examples.icon;

import java.util.Set;
import java.math.BigDecimal;
import java.math.RoundingMode;

import org.optaplanner.core.api.score.buildin.hardsoftbigdecimal.HardSoftBigDecimalScoreHolder;
import org.optaplanner.examples.icon.domain.Resource;
import org.optaplanner.examples.icon.domain.Task;
import org.optaplanner.examples.icon.domain.Machine;
import org.optaplanner.examples.icon.domain.MachineCapacity;
import org.optaplanner.examples.icon.domain.Period;
import org.optaplanner.examples.icon.domain.PeriodPowerCost;

import accumulate org.optaplanner.examples.icon.util.BigDecimalSumAccumulateFunction sumbd;

global HardSoftBigDecimalScoreHolder scoreHolder;
global BigDecimal costMultiplier;

// inner types
declare GoneIdle
    machine: Machine
    on: Period
end 

declare Shutdown
    machine: Machine
    on: Period
end 

declare Startup
    machine: Machine
    on: Period
    fromIdle : boolean
end 

rule "Determine cost multiplier"
salience 1000 // run first
when
    $total: Set() from collect(
        Period()
    )
then
    BigDecimal minutesInDay = BigDecimal.valueOf(1440);
    BigDecimal numOfPeriods = BigDecimal.valueOf($total.size());
    BigDecimal resolution = minutesInDay.divide(numOfPeriods); // minutes per period
    BigDecimal sixty = BigDecimal.valueOf(60); // hours per period
    drools.getWorkingMemory().setGlobal("costMultiplier", resolution.divide(sixty, 3, RoundingMode.HALF_UP));
end

// ################ activity information ########################

declare ActiveMachine
    during: Period
    machine: Machine
end

rule "Is Machine active at a given time?"
when
    $m: Machine()
    $p: Period()
    exists Task(executor == $m, $p >= startPeriod, $p <= finalPeriod)
then
    insertLogical(new ActiveMachine($p, $m));
end

declare ActiveTask
    during: Period
    machine: Machine
    task: Task
end

rule "Is task active at a given time?"
when
    $t: Task(isInitialized(), $start: startPeriod, $end: finalPeriod)
    $p: Period(this >= $start, this <= $end)
then
    insertLogical(new ActiveTask($p, $t.getExecutor(), $t));
end

// ################# hard constraints ###########################
declare MachineResourceOverusePerPeriod
    overuse: int
    resource: Resource
    machine: Machine
    period: Period
end

rule "Resource overuse per machine per period"
when
    ActiveMachine($p: during, $m: machine)
    MachineCapacity(machine == $m, $r: resource, $capacity: capacity)
    $use: Number(intValue > $capacity) from accumulate (
        ActiveTask(during == $p, machine == $m, $t: task);
        sum( $t.getConsumption($r).getConsumption() )
    )
then
    insertLogical(new MachineResourceOverusePerPeriod($use.intValue() - $capacity, $r, $m, $p));
end

rule "Resource overuse sum"
when
    $total: Number() from accumulate(
        MachineResourceOverusePerPeriod($partial: overuse);
        sum($partial)
    )
then
    scoreHolder.addHardConstraintMatch(kcontext, BigDecimal.valueOf($total.intValue()).negate());
end

// ################# objective function ###########################
rule "Calculate costs for task power consumption, per task"
when
    $task: Task(isInitialized(), $start: startPeriod, $end: finalPeriod)
    $cost: BigDecimal() from accumulate(
        PeriodPowerCost(period >= $start, period <= $end, $partial: cost);
        sumbd( $partial )
    )
then
    BigDecimal costPerTask = $cost.multiply($task.getPowerConsumption());
    BigDecimal adjustedCost = costPerTask.multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, adjustedCost.negate());
end

// detect idle, startup and shutdown
rule "Detect going idle"
when
    $t: Task(isInitialized(), !getShutdownPossible(), $m: executor, $end: finalPeriod)
    not Task(isInitialized(), executor == $m, startPeriod <= $end, finalPeriod > $end)
then
    insertLogical(new GoneIdle($m, $end));
end

rule "Detect shutdown"
when
    $t: Task(isInitialized(), getShutdownPossible(), $m: executor, $end: finalPeriod)
    not Task(isInitialized(), executor == $m, startPeriod <= $end, finalPeriod > $end)
then
    insertLogical(new Shutdown($m, $end));
end

rule "Detect startup"
when
    $t: Task(isInitialized(), $m: executor, $start: startPeriod)
    not Task(isInitialized(), executor == $m, startPeriod < $start, finalPeriod >= $start)
then
    insertLogical(new Startup($m, $start, false));
end

// penalize idle, startup, shutdown
rule "Detect and penalize idle periods"
no-loop
when
    $m: Machine()
    GoneIdle(machine == $m, $s: on)
    $nextStartup: Startup(machine == $m, on > $s, $s2: on)
    not Startup(on > $s, on < $s2) // make sure there is no other startup between $s and $s2
    $totalCost: BigDecimal() from accumulate (
        PeriodPowerCost(period > $s, period < $s2, $c: cost);
        sumbd( $c ) 
    )
then
    modify ($nextStartup) {
        setFromIdle(true);
    }
    BigDecimal costPerMachine = $totalCost.multiply($m.getCostWhenIdle());
    BigDecimal adjustedCost = costPerMachine.multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, adjustedCost.negate());
end

rule "Penalize startups from shutdowns"
when
    $m: Machine()
    $startups: Set ( size > 0 ) from accumulate (
        Startup(!fromIdle, machine == $m, $s: on);
        collectSet ( $s )
    )
then
    BigDecimal size = BigDecimal.valueOf($startups.size());
    BigDecimal cost = $m.getCostOnStartup().multiply(size).negate();
    scoreHolder.addSoftConstraintMatch(kcontext, cost);
end

rule "Penalize shutdowns"
when
    $m: Machine()
    $shutdowns: Set ( size > 0 ) from accumulate (
        Shutdown(machine == $m, $s: on);
        collectSet ( $s )
    )
then
    BigDecimal size = BigDecimal.valueOf($shutdowns.size());
    BigDecimal cost = $m.getCostOnShutdown().multiply(size).negate();
    scoreHolder.addSoftConstraintMatch(kcontext, cost);
end