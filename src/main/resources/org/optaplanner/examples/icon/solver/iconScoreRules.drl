package org.optaplanner.examples.icon;

import java.util.Set;
import java.math.BigDecimal;
import java.math.RoundingMode;

import org.optaplanner.core.api.score.buildin.hardsoftbigdecimal.HardSoftBigDecimalScoreHolder;
import org.optaplanner.examples.icon.domain.Resource;
import org.optaplanner.examples.icon.domain.Task;
import org.optaplanner.examples.icon.domain.Machine;
import org.optaplanner.examples.icon.domain.Period;
import org.optaplanner.examples.icon.domain.PeriodPowerCost;

import accumulate org.optaplanner.examples.icon.util.BigDecimalSumAccumulateFunction sumbd;

global HardSoftBigDecimalScoreHolder scoreHolder;
global BigDecimal costMultiplier;

// inner types
declare GoneIdle
    machine: Machine
    on: Period
end 

declare Shutdown
    machine: Machine
    on: Period
end 

declare Startup
    machine: Machine
    on: Period
    fromIdle : boolean
end 

rule "Determine cost multiplier"
salience 1000 // run first
when
    $total: Set() from collect(
        PeriodPowerCost()
    )
then
    BigDecimal minutesInDay = BigDecimal.valueOf(1440);
    BigDecimal numOfPeriods = BigDecimal.valueOf($total.size());
    BigDecimal resolution = minutesInDay.divide(numOfPeriods); // minutes per period
    BigDecimal sixty = BigDecimal.valueOf(60); // hours per period
    drools.getWorkingMemory().setGlobal("costMultiplier", resolution.divide(sixty, 17, RoundingMode.HALF_UP));
end

// ################# hard constraints ###########################
rule "Resource utilization"
when
    $p: Period()
    $m: Machine()
    $r: Resource()
    $consumption: Number(intValue > $m.getResourceCapacity($r)) from accumulate (
        $t: Task(
            isInitialized(), 
            executor == $m, 
            $p >= startPeriod,
            $p <= finalPeriod
        );
        sum( $t.getResourceConsumption($r) )
    )
then
    int capacity = $m.getResourceCapacity($r);
    int cons = $consumption.intValue();
    int result = capacity - cons;
    BigDecimal overreach = BigDecimal.valueOf(result);
    scoreHolder.addHardConstraintMatch(kcontext, overreach);
end

// ################# objective function ###########################
rule "Calculate costs for task power consumption, period by period"
when
    $cost: PeriodPowerCost($p: period) // shorthand to not have to match Period() first
    $consumption: BigDecimal(this.compareTo(BigDecimal.ZERO) > 0) from accumulate (
        $t: Task(
            isInitialized(), 
            $p >= startPeriod,
            $p <= finalPeriod
        );
        sumbd( $t.getPowerConsumption() )
    )
then
    BigDecimal costPerPeriod = $consumption.multiply($cost.getCost());
    BigDecimal adjustedCost = costPerPeriod.multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, adjustedCost.negate());
end

// detect idle, startup and shutdown
rule "Detect going idle"
when
    $t: Task(isInitialized(), !getShutdownPossible(), $m: executor, $end: finalPeriod)
    not Task(isInitialized(), executor == $m, startPeriod <= $end, finalPeriod > $end)
then
    insertLogical(new GoneIdle($m, $end));
end

rule "Detect shutdown"
when
    $t: Task(isInitialized(), getShutdownPossible(), $m: executor, $end: finalPeriod)
    not Task(isInitialized(), executor == $m, startPeriod <= $end, finalPeriod > $end)
then
    insertLogical(new Shutdown($m, $end));
end

rule "Detect startup"
when
    $t: Task(isInitialized(), $m: executor, $start: startPeriod)
    not Task(isInitialized(), executor == $m, startPeriod < $start, finalPeriod >= $start)
then
    insertLogical(new Startup($m, $start, false));
end

// penalize idle, startup, shutdown
rule "Detect and penalize idle periods"
no-loop
when
    $m: Machine()
    GoneIdle(machine == $m, $s: on)
    $nextStartup: Startup(machine == $m, on > $s, $s2: on)
    not Startup(on > $s, on < $s2) // make sure there is no other startup between $s and $s2
    $totalCost: BigDecimal() from accumulate (
        PeriodPowerCost(period > $s, period < $s2, $c: cost);
        sumbd( $c ) 
    )
then
    modify ($nextStartup) {
        setFromIdle(true);
    }
    BigDecimal costPerMachine = $totalCost.multiply($m.getCostWhenIdle());
    BigDecimal adjustedCost = costPerMachine.multiply(costMultiplier);
    scoreHolder.addSoftConstraintMatch(kcontext, adjustedCost.negate());
end

rule "Penalize startups from shutdowns"
when
    $m: Machine()
    $startups: Set ( size > 0 ) from accumulate (
        Startup(!fromIdle, machine == $m, $s: on);
        collectSet ( $s )
    )
then
    BigDecimal size = BigDecimal.valueOf($startups.size());
    BigDecimal cost = $m.getCostOnStartup().multiply(size).negate();
    scoreHolder.addSoftConstraintMatch(kcontext, cost);
end

rule "Penalize shutdowns"
when
    $m: Machine()
    $shutdowns: Set ( size > 0 ) from accumulate (
        Shutdown(machine == $m, $s: on);
        collectSet ( $s )
    )
then
    BigDecimal size = BigDecimal.valueOf($shutdowns.size());
    BigDecimal cost = $m.getCostOnShutdown().multiply(size).negate();
    scoreHolder.addSoftConstraintMatch(kcontext, cost);
end