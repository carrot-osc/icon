package org.optaplanner.examples.icon;

import java.util.Set;
import java.math.BigDecimal;

import org.optaplanner.core.api.score.buildin.hardsoftbigdecimal.HardSoftBigDecimalScoreHolder;
import org.optaplanner.examples.icon.domain.Resource;
import org.optaplanner.examples.icon.domain.Task;
import org.optaplanner.examples.icon.domain.Machine;
import org.optaplanner.examples.icon.domain.Period;
import org.optaplanner.examples.icon.domain.PeriodPowerCost;

import accumulate org.optaplanner.examples.icon.util.BigDecimalSumAccumulateFunction sumbd;

global HardSoftBigDecimalScoreHolder scoreHolder;

// inner types
declare GoneIdle
    machine: Machine
    on: Period
end 

declare Shutdown
    machine: Machine
    on: Period
end 

declare Startup
    machine: Machine
    on: Period
    fromIdle : boolean
end 

// hard constraints
rule "Resource utilization"
when
    $p: Period()
    $m: Machine()
    $r: Resource()
    $consumption: Number(intValue > 0) from accumulate (
        $t: Task(
            isInitialized(), 
            executor == $m, 
            $p >= startPeriod,
            $p <= finalPeriod
        );
        sum( $t.getResourceConsumption($r))
    )
then
    int capacity = $m.getResourceCapacity($r);
    int cons = $consumption.intValue();
    int result = Math.min(0, capacity - cons);
    BigDecimal overreach = BigDecimal.valueOf(result);
    scoreHolder.addHardConstraintMatch(kcontext, overreach);
end

// objective function

rule "Calculate costs for task power consumption, period by period"
when
    $p: Period()
    $consumption: BigDecimal(this.compareTo(BigDecimal.ZERO) > 0) from accumulate (
        $t: Task(
            isInitialized(), 
            $p >= startPeriod,
            $p <= finalPeriod
        );
        sumbd( $t.getPowerConsumption() )
    )
    $cost: PeriodPowerCost(period == $p)
then
    scoreHolder.addSoftConstraintMatch(kcontext, $consumption.multiply($cost.getCost()).negate());
end

// detect idle, startup and shutdown
rule "Detect going idle"
when
    $t: Task(isInitialized(), !getShutdownPossible(), $m: executor, $end: finalPeriod)
    not Task(isInitialized(), executor == $m, startPeriod <= $end, finalPeriod > $end)
then
    insertLogical(new GoneIdle($m, $end));
end

rule "Detect shutdown"
when
    $t: Task(isInitialized(), getShutdownPossible(), $m: executor, $end: finalPeriod)
    not Task(isInitialized(), executor == $m, startPeriod <= $end, finalPeriod > $end)
then
    insertLogical(new Shutdown($m, $end));
end

rule "Detect startup"
when
    $t: Task(isInitialized(), $m: executor, $start: startPeriod)
    not Task(isInitialized(), executor == $m, startPeriod < $start, finalPeriod >= $start)
then
    insertLogical(new Startup($m, $start, false));
end

// penalize idle, startup, shutdown
rule "Detect and penalize idle periods"
no-loop
when
    $m: Machine()
    GoneIdle(machine == $m, $s: on)
    $nextStartup: Startup(machine == $m, on > $s, $s2: on)
    not Startup(on > $s, on < $s2) // make sure there is no other startup between $s and $s2
    $totalCost: BigDecimal() from accumulate (
        PeriodPowerCost(period > $s, period < $s2, $c: cost);
        sumbd( $c.multiply($m.getCostWhenIdle()) ) 
    )
then
    modify ($nextStartup) {
        setFromIdle(true);
    }
    scoreHolder.addSoftConstraintMatch(kcontext, $totalCost.negate());
end

rule "Penalize startups from shutdowns"
when
    $m: Machine()
    $startups: Set ( size > 0 ) from accumulate (
        Startup(!fromIdle, machine == $m, $s: on);
        collectSet ( $s )
    )
then
    BigDecimal size = BigDecimal.valueOf($startups.size());
    BigDecimal cost = $m.getCostOnStartup().multiply(size).negate();
    scoreHolder.addSoftConstraintMatch(kcontext, cost);
end

rule "Penalize shutdowns"
when
    $m: Machine()
    $shutdowns: Set ( size > 0 ) from accumulate (
        Shutdown(machine == $m, $s: on);
        collectSet ( $s )
    )
then
    BigDecimal size = BigDecimal.valueOf($shutdowns.size());
    BigDecimal cost = $m.getCostOnShutdown().multiply(size).negate();
    scoreHolder.addSoftConstraintMatch(kcontext, cost);
end